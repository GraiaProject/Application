<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>graia.broadcast API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>graia.broadcast</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import asyncio
import sys
import traceback
from typing import (
    Callable,
    Dict,
    Generator,
    Iterable,
    List,
    Set,
    Type,
    Union,
)

from iterwrapper import IterWrapper as iw

from graia.broadcast.entities.track_log import TrackLog, TrackLogType

from .typing import T_Dispatcher

from .entities.exectarget import ExecTarget

from .interfaces.dispatcher import DispatcherInterface
from .entities.decorator import Decorator
from .entities.dispatcher import BaseDispatcher
from .entities.event import BaseEvent
from .entities.listener import Listener
from .entities.namespace import Namespace
from .entities.signatures import Force, RemoveMe
from .exceptions import (
    DisabledNamespace,
    ExecutionStop,
    ExistedNamespace,
    InvaildEventName,
    PropagationCancelled,
    RegisteredEventListener,
    RequirementCrashed,
    UnexistedNamespace,
)
from .interfaces.decorator import DecoratorInterface
from .utilles import (
    argument_signature,
    dispatcher_mixin_handler,
    group_dict,
    printer,
    run_always_await_safely,
    cached_isinstance,
)
from .typing import T_Dispatcher


class Broadcast:
    loop: asyncio.AbstractEventLoop

    default_namespace: Namespace
    namespaces: List[Namespace]
    listeners: List[Listener]

    dispatcher_interface: DispatcherInterface

    debug_flag: bool

    def __init__(
        self,
        *,
        loop: asyncio.AbstractEventLoop = None,
        debug_flag: bool = False,
    ):
        self.loop = loop or asyncio.get_event_loop()
        self.default_namespace = Namespace(name=&#34;default&#34;, default=True)
        self.debug_flag = debug_flag
        self.namespaces = []
        self.listeners = []
        self.dispatcher_interface = DispatcherInterface(self)
        self.dispatcher_interface.execution_contexts[0].dispatchers.insert(
            0, DecoratorInterface(self.dispatcher_interface)
        )

        @self.dispatcher_interface.inject_global_raw
        async def _(interface: DispatcherInterface):
            if interface.annotation is interface.event.__class__:
                return interface.event
            elif interface.annotation is Broadcast:
                return interface.broadcast
            elif interface.annotation is DispatcherInterface:
                return interface

    def default_listener_generator(self, event_class) -&gt; Iterable[Listener]:
        return (
            iw(self.listeners)
            .filter(lambda x: not x.namespace.hide)  # filter for hide
            .filter(lambda x: not x.namespace.disabled)  # filter for disabled
            .filter(lambda x: event_class in x.listening_events)
            # .collect(list)  # collect to a whole list
        )

    async def layered_scheduler(
        self, listener_generator: Generator[Listener, None, None], event: BaseEvent
    ):
        grouped: Dict[int, List[Listener]] = group_dict(
            listener_generator, lambda x: x.priority
        )
        for _, current_group in sorted(grouped.items(), key=lambda x: x[0]):
            coros = [self.Executor(target=i, event=event) for i in current_group]
            done_tasks, _ = await asyncio.wait(coros)
            for task in done_tasks:
                if task.exception().__class__ is PropagationCancelled:
                    break

    async def Executor(
        self,
        target: Union[Callable, ExecTarget],
        event: BaseEvent,
        dispatchers: List[
            Union[
                Type[BaseDispatcher],
                Callable,
                BaseDispatcher,
            ]
        ] = None,
        post_exception_event: bool = False,
        print_exception: bool = True,
        enableInternalAccess: bool = False,
    ):
        from .builtin.event import ExceptionThrowed

        is_exectarget = cached_isinstance(target, ExecTarget)
        is_listener = cached_isinstance(target, Listener)

        if is_listener:
            if target.namespace.disabled:
                raise DisabledNamespace(
                    &#34;catched a disabled namespace: {0}&#34;.format(target.namespace.name)
                )

        target_callable = target.callable if is_exectarget else target
        parameter_compile_result = {}
        complete_finished = False

        track_logs: TrackLog = TrackLog()
        async with self.dispatcher_interface.start_execution(
            event,
            [
                *(dispatchers or []),
                *(target.namespace.injected_dispatchers if is_listener else []),
                *(target.inline_dispatchers if is_exectarget else []),
                *dispatcher_mixin_handler(event.Dispatcher),
            ],
            track_logs,
        ) as dii:
            if enableInternalAccess or (
                is_exectarget and target.enable_internal_access
            ):

                @dii.inject_execution_raw
                async def _(interface: DispatcherInterface):
                    if interface.annotation is target.__class__:
                        return target
                    elif interface.annotation is Namespace and is_listener:
                        return target.namespace

            await dii.exec_lifecycle(&#34;beforeExecution&#34;)
            try:
                await dii.exec_lifecycle(&#34;beforeDispatch&#34;)

                if is_exectarget:
                    if target.maybe_failure:
                        initial_path = dii.init_dispatch_path()
                        for name, annotation, default in argument_signature(
                            target_callable
                        ):
                            if (
                                target.param_paths.setdefault(name, initial_path)
                                is initial_path
                            ):
                                target.param_paths[name + &#34;$set&#34;] = set()
                            parameter_compile_result[name] = await dii.lookup_param(
                                name, annotation, default, target.param_paths[name]
                            )
                    else:
                        for name, annotation, default in argument_signature(
                            target_callable
                        ):
                            parameter_compile_result[
                                name
                            ] = await dii.lookup_param_without_log(
                                name, annotation, default, target.param_paths[name]
                            )

                    for hl_d in target.headless_decorators:
                        await dii.lookup_param_without_log(None, None, hl_d)
                else:
                    for name, annotation, default in argument_signature(
                        target_callable
                    ):
                        parameter_compile_result[
                            name
                        ] = await dii.lookup_param_without_log(
                            name, annotation, default, target.param_paths[name]
                        )

                complete_finished = True

                result = await run_always_await_safely(
                    target_callable, **parameter_compile_result
                )
            except (ExecutionStop, PropagationCancelled):
                raise
            except RequirementCrashed:
                traceback.print_exc()
                raise
            except Exception as e:
                if print_exception or event.__class__ is ExceptionThrowed:
                    traceback.print_exc()
                if post_exception_event and event.__class__ is not ExceptionThrowed:
                    self.postEvent(ExceptionThrowed(exception=e, event=event))
                raise
            finally:
                _, exception, tb = sys.exc_info()
                await dii.exec_lifecycle(&#34;afterDispatch&#34;, exception, tb)
                await dii.exec_lifecycle(&#34;afterTargetExec&#34;, exception, tb)
                await dii.exec_lifecycle(&#34;afterExecution&#34;, exception, tb)

                if is_exectarget and not track_logs.fluent_success:
                    current_paths = target.param_paths
                    current_path: List[List[&#34;T_Dispatcher&#34;]] = None
                    current_path_set: Set[&#34;T_Dispatcher&#34;] = None
                    has_failures: set = set()

                    for log in track_logs.log:
                        if log[0] is TrackLogType.LookupStart:
                            current_path = current_paths[log[1]]
                            current_path_set = current_paths[log[1] + &#34;$set&#34;]
                        elif log[0] is TrackLogType.LookupEnd:
                            current_path = None
                        elif (
                            current_path is not None
                            and log[0] is TrackLogType.Result
                            and log[2] not in current_path_set
                        ):
                            current_path[0].append(log[2])
                            current_path_set.add(log[2])
                        elif log[0] is TrackLogType.Continue:
                            has_failures.add(log[1])

                    target.maybe_failure.symmetric_difference_update(has_failures)

            if result.__class__ is Force:
                return result.content

            if result.__class__ is RemoveMe:
                if cached_isinstance(target, Listener):
                    if target in self.listeners:
                        self.listeners.pop(self.listeners.index(target))

            return result

    def postEvent(self, event: BaseEvent):
        self.loop.create_task(
            self.layered_scheduler(
                listener_generator=self.default_listener_generator(event.__class__),
                event=event,
            )
        )

    @staticmethod
    def event_class_generator(target=BaseEvent):
        for i in target.__subclasses__():
            yield i
            if i.__subclasses__():
                yield from Broadcast.event_class_generator(i)

    @staticmethod
    def findEvent(name: str):
        for i in Broadcast.event_class_generator():
            if i.__name__ == name:
                return i

    def getDefaultNamespace(self):
        return self.default_namespace

    def createNamespace(
        self, name, *, priority: int = 0, hide: bool = False, disabled: bool = False
    ):
        if self.containNamespace(name):
            raise ExistedNamespace(name, &#34;has been created!&#34;)
        self.namespaces.append(
            Namespace(name=name, priority=priority, hide=hide, disabled=disabled)
        )
        return self.namespaces[-1]

    def removeNamespace(self, name):
        if self.containNamespace(name):
            for index, i in enumerate(self.namespaces):
                if i.name == name:
                    self.namespaces.pop(index)
                    return
        else:
            raise UnexistedNamespace(name)

    def containNamespace(self, name):
        for i in self.namespaces:
            if i.name == name:
                return True
        return False

    def getNamespace(self, name):
        if self.containNamespace(name):
            for i in self.namespaces:
                if i.name == name:
                    return i
        else:
            raise UnexistedNamespace(name)

    def hideNamespace(self, name):
        ns = self.getNamespace(name)
        ns.hide = True

    def unhideNamespace(self, name):
        ns = self.getNamespace(name)
        ns.hide = False

    def disableNamespace(self, name):
        ns = self.getNamespace(name)
        ns.disabled = True

    def enableNamespace(self, name):
        ns = self.getNamespace(name)
        ns.disabled = False

    def containListener(self, target):
        for i in self.listeners:
            if i.callable == target:
                return True
        return False

    def getListener(self, target):
        for i in self.listeners:
            if i.callable == target:
                return i

    def removeListener(self, target):
        self.listeners.remove(target)

    def receiver(
        self,
        event: Union[str, Type[BaseEvent]],
        priority: int = 16,
        dispatchers: List[Type[BaseDispatcher]] = [],
        namespace: Namespace = None,
        headless_decorators: List[Decorator] = [],
        enable_internal_access: bool = False,
    ):
        if cached_isinstance(event, str):
            _name = event
            event = self.findEvent(event)
            if not event:
                raise InvaildEventName(_name, &#34;is not vaild!&#34;)
        priority = (type(priority) == int) and priority or int(priority)  # 类型转换

        def receiver_wrapper(callable_target):
            may_listener = self.getListener(callable_target)
            if not may_listener:
                self.listeners.append(
                    Listener(
                        callable=callable_target,
                        namespace=namespace or self.getDefaultNamespace(),
                        inline_dispatchers=dispatchers,
                        priority=priority,
                        listening_events=[event],
                        headless_decorators=headless_decorators,
                        enable_internal_access=enable_internal_access,
                    )
                )
            else:
                if event not in may_listener.listening_events:
                    may_listener.listening_events.append(event)
                else:
                    raise RegisteredEventListener(
                        event.__name__, &#34;has been registered!&#34;
                    )
            return callable_target

        return receiver_wrapper</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="graia.broadcast.builtin" href="builtin/index.html">graia.broadcast.builtin</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="graia.broadcast.entities" href="entities/index.html">graia.broadcast.entities</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="graia.broadcast.exceptions" href="exceptions.html">graia.broadcast.exceptions</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="graia.broadcast.interfaces" href="interfaces/index.html">graia.broadcast.interfaces</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="graia.broadcast.interrupt" href="interrupt/index.html">graia.broadcast.interrupt</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="graia.broadcast.priority" href="priority.html">graia.broadcast.priority</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="graia.broadcast.typing" href="typing.html">graia.broadcast.typing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="graia.broadcast.utilles" href="utilles.html">graia.broadcast.utilles</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="graia.broadcast.Broadcast"><code class="flex name class">
<span>class <span class="ident">Broadcast</span></span>
<span>(</span><span>*, loop: asyncio.events.AbstractEventLoop = None, debug_flag: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Broadcast:
    loop: asyncio.AbstractEventLoop

    default_namespace: Namespace
    namespaces: List[Namespace]
    listeners: List[Listener]

    dispatcher_interface: DispatcherInterface

    debug_flag: bool

    def __init__(
        self,
        *,
        loop: asyncio.AbstractEventLoop = None,
        debug_flag: bool = False,
    ):
        self.loop = loop or asyncio.get_event_loop()
        self.default_namespace = Namespace(name=&#34;default&#34;, default=True)
        self.debug_flag = debug_flag
        self.namespaces = []
        self.listeners = []
        self.dispatcher_interface = DispatcherInterface(self)
        self.dispatcher_interface.execution_contexts[0].dispatchers.insert(
            0, DecoratorInterface(self.dispatcher_interface)
        )

        @self.dispatcher_interface.inject_global_raw
        async def _(interface: DispatcherInterface):
            if interface.annotation is interface.event.__class__:
                return interface.event
            elif interface.annotation is Broadcast:
                return interface.broadcast
            elif interface.annotation is DispatcherInterface:
                return interface

    def default_listener_generator(self, event_class) -&gt; Iterable[Listener]:
        return (
            iw(self.listeners)
            .filter(lambda x: not x.namespace.hide)  # filter for hide
            .filter(lambda x: not x.namespace.disabled)  # filter for disabled
            .filter(lambda x: event_class in x.listening_events)
            # .collect(list)  # collect to a whole list
        )

    async def layered_scheduler(
        self, listener_generator: Generator[Listener, None, None], event: BaseEvent
    ):
        grouped: Dict[int, List[Listener]] = group_dict(
            listener_generator, lambda x: x.priority
        )
        for _, current_group in sorted(grouped.items(), key=lambda x: x[0]):
            coros = [self.Executor(target=i, event=event) for i in current_group]
            done_tasks, _ = await asyncio.wait(coros)
            for task in done_tasks:
                if task.exception().__class__ is PropagationCancelled:
                    break

    async def Executor(
        self,
        target: Union[Callable, ExecTarget],
        event: BaseEvent,
        dispatchers: List[
            Union[
                Type[BaseDispatcher],
                Callable,
                BaseDispatcher,
            ]
        ] = None,
        post_exception_event: bool = False,
        print_exception: bool = True,
        enableInternalAccess: bool = False,
    ):
        from .builtin.event import ExceptionThrowed

        is_exectarget = cached_isinstance(target, ExecTarget)
        is_listener = cached_isinstance(target, Listener)

        if is_listener:
            if target.namespace.disabled:
                raise DisabledNamespace(
                    &#34;catched a disabled namespace: {0}&#34;.format(target.namespace.name)
                )

        target_callable = target.callable if is_exectarget else target
        parameter_compile_result = {}
        complete_finished = False

        track_logs: TrackLog = TrackLog()
        async with self.dispatcher_interface.start_execution(
            event,
            [
                *(dispatchers or []),
                *(target.namespace.injected_dispatchers if is_listener else []),
                *(target.inline_dispatchers if is_exectarget else []),
                *dispatcher_mixin_handler(event.Dispatcher),
            ],
            track_logs,
        ) as dii:
            if enableInternalAccess or (
                is_exectarget and target.enable_internal_access
            ):

                @dii.inject_execution_raw
                async def _(interface: DispatcherInterface):
                    if interface.annotation is target.__class__:
                        return target
                    elif interface.annotation is Namespace and is_listener:
                        return target.namespace

            await dii.exec_lifecycle(&#34;beforeExecution&#34;)
            try:
                await dii.exec_lifecycle(&#34;beforeDispatch&#34;)

                if is_exectarget:
                    if target.maybe_failure:
                        initial_path = dii.init_dispatch_path()
                        for name, annotation, default in argument_signature(
                            target_callable
                        ):
                            if (
                                target.param_paths.setdefault(name, initial_path)
                                is initial_path
                            ):
                                target.param_paths[name + &#34;$set&#34;] = set()
                            parameter_compile_result[name] = await dii.lookup_param(
                                name, annotation, default, target.param_paths[name]
                            )
                    else:
                        for name, annotation, default in argument_signature(
                            target_callable
                        ):
                            parameter_compile_result[
                                name
                            ] = await dii.lookup_param_without_log(
                                name, annotation, default, target.param_paths[name]
                            )

                    for hl_d in target.headless_decorators:
                        await dii.lookup_param_without_log(None, None, hl_d)
                else:
                    for name, annotation, default in argument_signature(
                        target_callable
                    ):
                        parameter_compile_result[
                            name
                        ] = await dii.lookup_param_without_log(
                            name, annotation, default, target.param_paths[name]
                        )

                complete_finished = True

                result = await run_always_await_safely(
                    target_callable, **parameter_compile_result
                )
            except (ExecutionStop, PropagationCancelled):
                raise
            except RequirementCrashed:
                traceback.print_exc()
                raise
            except Exception as e:
                if print_exception or event.__class__ is ExceptionThrowed:
                    traceback.print_exc()
                if post_exception_event and event.__class__ is not ExceptionThrowed:
                    self.postEvent(ExceptionThrowed(exception=e, event=event))
                raise
            finally:
                _, exception, tb = sys.exc_info()
                await dii.exec_lifecycle(&#34;afterDispatch&#34;, exception, tb)
                await dii.exec_lifecycle(&#34;afterTargetExec&#34;, exception, tb)
                await dii.exec_lifecycle(&#34;afterExecution&#34;, exception, tb)

                if is_exectarget and not track_logs.fluent_success:
                    current_paths = target.param_paths
                    current_path: List[List[&#34;T_Dispatcher&#34;]] = None
                    current_path_set: Set[&#34;T_Dispatcher&#34;] = None
                    has_failures: set = set()

                    for log in track_logs.log:
                        if log[0] is TrackLogType.LookupStart:
                            current_path = current_paths[log[1]]
                            current_path_set = current_paths[log[1] + &#34;$set&#34;]
                        elif log[0] is TrackLogType.LookupEnd:
                            current_path = None
                        elif (
                            current_path is not None
                            and log[0] is TrackLogType.Result
                            and log[2] not in current_path_set
                        ):
                            current_path[0].append(log[2])
                            current_path_set.add(log[2])
                        elif log[0] is TrackLogType.Continue:
                            has_failures.add(log[1])

                    target.maybe_failure.symmetric_difference_update(has_failures)

            if result.__class__ is Force:
                return result.content

            if result.__class__ is RemoveMe:
                if cached_isinstance(target, Listener):
                    if target in self.listeners:
                        self.listeners.pop(self.listeners.index(target))

            return result

    def postEvent(self, event: BaseEvent):
        self.loop.create_task(
            self.layered_scheduler(
                listener_generator=self.default_listener_generator(event.__class__),
                event=event,
            )
        )

    @staticmethod
    def event_class_generator(target=BaseEvent):
        for i in target.__subclasses__():
            yield i
            if i.__subclasses__():
                yield from Broadcast.event_class_generator(i)

    @staticmethod
    def findEvent(name: str):
        for i in Broadcast.event_class_generator():
            if i.__name__ == name:
                return i

    def getDefaultNamespace(self):
        return self.default_namespace

    def createNamespace(
        self, name, *, priority: int = 0, hide: bool = False, disabled: bool = False
    ):
        if self.containNamespace(name):
            raise ExistedNamespace(name, &#34;has been created!&#34;)
        self.namespaces.append(
            Namespace(name=name, priority=priority, hide=hide, disabled=disabled)
        )
        return self.namespaces[-1]

    def removeNamespace(self, name):
        if self.containNamespace(name):
            for index, i in enumerate(self.namespaces):
                if i.name == name:
                    self.namespaces.pop(index)
                    return
        else:
            raise UnexistedNamespace(name)

    def containNamespace(self, name):
        for i in self.namespaces:
            if i.name == name:
                return True
        return False

    def getNamespace(self, name):
        if self.containNamespace(name):
            for i in self.namespaces:
                if i.name == name:
                    return i
        else:
            raise UnexistedNamespace(name)

    def hideNamespace(self, name):
        ns = self.getNamespace(name)
        ns.hide = True

    def unhideNamespace(self, name):
        ns = self.getNamespace(name)
        ns.hide = False

    def disableNamespace(self, name):
        ns = self.getNamespace(name)
        ns.disabled = True

    def enableNamespace(self, name):
        ns = self.getNamespace(name)
        ns.disabled = False

    def containListener(self, target):
        for i in self.listeners:
            if i.callable == target:
                return True
        return False

    def getListener(self, target):
        for i in self.listeners:
            if i.callable == target:
                return i

    def removeListener(self, target):
        self.listeners.remove(target)

    def receiver(
        self,
        event: Union[str, Type[BaseEvent]],
        priority: int = 16,
        dispatchers: List[Type[BaseDispatcher]] = [],
        namespace: Namespace = None,
        headless_decorators: List[Decorator] = [],
        enable_internal_access: bool = False,
    ):
        if cached_isinstance(event, str):
            _name = event
            event = self.findEvent(event)
            if not event:
                raise InvaildEventName(_name, &#34;is not vaild!&#34;)
        priority = (type(priority) == int) and priority or int(priority)  # 类型转换

        def receiver_wrapper(callable_target):
            may_listener = self.getListener(callable_target)
            if not may_listener:
                self.listeners.append(
                    Listener(
                        callable=callable_target,
                        namespace=namespace or self.getDefaultNamespace(),
                        inline_dispatchers=dispatchers,
                        priority=priority,
                        listening_events=[event],
                        headless_decorators=headless_decorators,
                        enable_internal_access=enable_internal_access,
                    )
                )
            else:
                if event not in may_listener.listening_events:
                    may_listener.listening_events.append(event)
                else:
                    raise RegisteredEventListener(
                        event.__name__, &#34;has been registered!&#34;
                    )
            return callable_target

        return receiver_wrapper</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="graia.broadcast.Broadcast.debug_flag"><code class="name">var <span class="ident">debug_flag</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="graia.broadcast.Broadcast.default_namespace"><code class="name">var <span class="ident">default_namespace</span> : <a title="graia.broadcast.entities.namespace.Namespace" href="entities/namespace.html#graia.broadcast.entities.namespace.Namespace">Namespace</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="graia.broadcast.Broadcast.dispatcher_interface"><code class="name">var <span class="ident">dispatcher_interface</span> : <a title="graia.broadcast.interfaces.dispatcher.DispatcherInterface" href="interfaces/dispatcher.html#graia.broadcast.interfaces.dispatcher.DispatcherInterface">DispatcherInterface</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="graia.broadcast.Broadcast.listeners"><code class="name">var <span class="ident">listeners</span> : List[<a title="graia.broadcast.entities.listener.Listener" href="entities/listener.html#graia.broadcast.entities.listener.Listener">Listener</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="graia.broadcast.Broadcast.loop"><code class="name">var <span class="ident">loop</span> : asyncio.events.AbstractEventLoop</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="graia.broadcast.Broadcast.namespaces"><code class="name">var <span class="ident">namespaces</span> : List[<a title="graia.broadcast.entities.namespace.Namespace" href="entities/namespace.html#graia.broadcast.entities.namespace.Namespace">Namespace</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="graia.broadcast.Broadcast.event_class_generator"><code class="name flex">
<span>def <span class="ident">event_class_generator</span></span>(<span>target=graia.broadcast.entities.event.BaseEvent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def event_class_generator(target=BaseEvent):
    for i in target.__subclasses__():
        yield i
        if i.__subclasses__():
            yield from Broadcast.event_class_generator(i)</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.findEvent"><code class="name flex">
<span>def <span class="ident">findEvent</span></span>(<span>name: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def findEvent(name: str):
    for i in Broadcast.event_class_generator():
        if i.__name__ == name:
            return i</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="graia.broadcast.Broadcast.Executor"><code class="name flex">
<span>async def <span class="ident">Executor</span></span>(<span>self, target: Union[Callable, <a title="graia.broadcast.entities.exectarget.ExecTarget" href="entities/exectarget.html#graia.broadcast.entities.exectarget.ExecTarget">ExecTarget</a>], event: <a title="graia.broadcast.entities.event.BaseEvent" href="entities/event.html#graia.broadcast.entities.event.BaseEvent">BaseEvent</a>, dispatchers: List[Union[Type[<a title="graia.broadcast.entities.dispatcher.BaseDispatcher" href="entities/dispatcher.html#graia.broadcast.entities.dispatcher.BaseDispatcher">BaseDispatcher</a>], Callable, <a title="graia.broadcast.entities.dispatcher.BaseDispatcher" href="entities/dispatcher.html#graia.broadcast.entities.dispatcher.BaseDispatcher">BaseDispatcher</a>]] = None, post_exception_event: bool = False, print_exception: bool = True, enableInternalAccess: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def Executor(
    self,
    target: Union[Callable, ExecTarget],
    event: BaseEvent,
    dispatchers: List[
        Union[
            Type[BaseDispatcher],
            Callable,
            BaseDispatcher,
        ]
    ] = None,
    post_exception_event: bool = False,
    print_exception: bool = True,
    enableInternalAccess: bool = False,
):
    from .builtin.event import ExceptionThrowed

    is_exectarget = cached_isinstance(target, ExecTarget)
    is_listener = cached_isinstance(target, Listener)

    if is_listener:
        if target.namespace.disabled:
            raise DisabledNamespace(
                &#34;catched a disabled namespace: {0}&#34;.format(target.namespace.name)
            )

    target_callable = target.callable if is_exectarget else target
    parameter_compile_result = {}
    complete_finished = False

    track_logs: TrackLog = TrackLog()
    async with self.dispatcher_interface.start_execution(
        event,
        [
            *(dispatchers or []),
            *(target.namespace.injected_dispatchers if is_listener else []),
            *(target.inline_dispatchers if is_exectarget else []),
            *dispatcher_mixin_handler(event.Dispatcher),
        ],
        track_logs,
    ) as dii:
        if enableInternalAccess or (
            is_exectarget and target.enable_internal_access
        ):

            @dii.inject_execution_raw
            async def _(interface: DispatcherInterface):
                if interface.annotation is target.__class__:
                    return target
                elif interface.annotation is Namespace and is_listener:
                    return target.namespace

        await dii.exec_lifecycle(&#34;beforeExecution&#34;)
        try:
            await dii.exec_lifecycle(&#34;beforeDispatch&#34;)

            if is_exectarget:
                if target.maybe_failure:
                    initial_path = dii.init_dispatch_path()
                    for name, annotation, default in argument_signature(
                        target_callable
                    ):
                        if (
                            target.param_paths.setdefault(name, initial_path)
                            is initial_path
                        ):
                            target.param_paths[name + &#34;$set&#34;] = set()
                        parameter_compile_result[name] = await dii.lookup_param(
                            name, annotation, default, target.param_paths[name]
                        )
                else:
                    for name, annotation, default in argument_signature(
                        target_callable
                    ):
                        parameter_compile_result[
                            name
                        ] = await dii.lookup_param_without_log(
                            name, annotation, default, target.param_paths[name]
                        )

                for hl_d in target.headless_decorators:
                    await dii.lookup_param_without_log(None, None, hl_d)
            else:
                for name, annotation, default in argument_signature(
                    target_callable
                ):
                    parameter_compile_result[
                        name
                    ] = await dii.lookup_param_without_log(
                        name, annotation, default, target.param_paths[name]
                    )

            complete_finished = True

            result = await run_always_await_safely(
                target_callable, **parameter_compile_result
            )
        except (ExecutionStop, PropagationCancelled):
            raise
        except RequirementCrashed:
            traceback.print_exc()
            raise
        except Exception as e:
            if print_exception or event.__class__ is ExceptionThrowed:
                traceback.print_exc()
            if post_exception_event and event.__class__ is not ExceptionThrowed:
                self.postEvent(ExceptionThrowed(exception=e, event=event))
            raise
        finally:
            _, exception, tb = sys.exc_info()
            await dii.exec_lifecycle(&#34;afterDispatch&#34;, exception, tb)
            await dii.exec_lifecycle(&#34;afterTargetExec&#34;, exception, tb)
            await dii.exec_lifecycle(&#34;afterExecution&#34;, exception, tb)

            if is_exectarget and not track_logs.fluent_success:
                current_paths = target.param_paths
                current_path: List[List[&#34;T_Dispatcher&#34;]] = None
                current_path_set: Set[&#34;T_Dispatcher&#34;] = None
                has_failures: set = set()

                for log in track_logs.log:
                    if log[0] is TrackLogType.LookupStart:
                        current_path = current_paths[log[1]]
                        current_path_set = current_paths[log[1] + &#34;$set&#34;]
                    elif log[0] is TrackLogType.LookupEnd:
                        current_path = None
                    elif (
                        current_path is not None
                        and log[0] is TrackLogType.Result
                        and log[2] not in current_path_set
                    ):
                        current_path[0].append(log[2])
                        current_path_set.add(log[2])
                    elif log[0] is TrackLogType.Continue:
                        has_failures.add(log[1])

                target.maybe_failure.symmetric_difference_update(has_failures)

        if result.__class__ is Force:
            return result.content

        if result.__class__ is RemoveMe:
            if cached_isinstance(target, Listener):
                if target in self.listeners:
                    self.listeners.pop(self.listeners.index(target))

        return result</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.containListener"><code class="name flex">
<span>def <span class="ident">containListener</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def containListener(self, target):
    for i in self.listeners:
        if i.callable == target:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.containNamespace"><code class="name flex">
<span>def <span class="ident">containNamespace</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def containNamespace(self, name):
    for i in self.namespaces:
        if i.name == name:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.createNamespace"><code class="name flex">
<span>def <span class="ident">createNamespace</span></span>(<span>self, name, *, priority: int = 0, hide: bool = False, disabled: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createNamespace(
    self, name, *, priority: int = 0, hide: bool = False, disabled: bool = False
):
    if self.containNamespace(name):
        raise ExistedNamespace(name, &#34;has been created!&#34;)
    self.namespaces.append(
        Namespace(name=name, priority=priority, hide=hide, disabled=disabled)
    )
    return self.namespaces[-1]</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.default_listener_generator"><code class="name flex">
<span>def <span class="ident">default_listener_generator</span></span>(<span>self, event_class) ‑> Iterable[<a title="graia.broadcast.entities.listener.Listener" href="entities/listener.html#graia.broadcast.entities.listener.Listener">Listener</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_listener_generator(self, event_class) -&gt; Iterable[Listener]:
    return (
        iw(self.listeners)
        .filter(lambda x: not x.namespace.hide)  # filter for hide
        .filter(lambda x: not x.namespace.disabled)  # filter for disabled
        .filter(lambda x: event_class in x.listening_events)
        # .collect(list)  # collect to a whole list
    )</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.disableNamespace"><code class="name flex">
<span>def <span class="ident">disableNamespace</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disableNamespace(self, name):
    ns = self.getNamespace(name)
    ns.disabled = True</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.enableNamespace"><code class="name flex">
<span>def <span class="ident">enableNamespace</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enableNamespace(self, name):
    ns = self.getNamespace(name)
    ns.disabled = False</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.getDefaultNamespace"><code class="name flex">
<span>def <span class="ident">getDefaultNamespace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDefaultNamespace(self):
    return self.default_namespace</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.getListener"><code class="name flex">
<span>def <span class="ident">getListener</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getListener(self, target):
    for i in self.listeners:
        if i.callable == target:
            return i</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.getNamespace"><code class="name flex">
<span>def <span class="ident">getNamespace</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNamespace(self, name):
    if self.containNamespace(name):
        for i in self.namespaces:
            if i.name == name:
                return i
    else:
        raise UnexistedNamespace(name)</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.hideNamespace"><code class="name flex">
<span>def <span class="ident">hideNamespace</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hideNamespace(self, name):
    ns = self.getNamespace(name)
    ns.hide = True</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.layered_scheduler"><code class="name flex">
<span>async def <span class="ident">layered_scheduler</span></span>(<span>self, listener_generator: Generator[<a title="graia.broadcast.entities.listener.Listener" href="entities/listener.html#graia.broadcast.entities.listener.Listener">Listener</a>, NoneType, NoneType], event: <a title="graia.broadcast.entities.event.BaseEvent" href="entities/event.html#graia.broadcast.entities.event.BaseEvent">BaseEvent</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def layered_scheduler(
    self, listener_generator: Generator[Listener, None, None], event: BaseEvent
):
    grouped: Dict[int, List[Listener]] = group_dict(
        listener_generator, lambda x: x.priority
    )
    for _, current_group in sorted(grouped.items(), key=lambda x: x[0]):
        coros = [self.Executor(target=i, event=event) for i in current_group]
        done_tasks, _ = await asyncio.wait(coros)
        for task in done_tasks:
            if task.exception().__class__ is PropagationCancelled:
                break</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.postEvent"><code class="name flex">
<span>def <span class="ident">postEvent</span></span>(<span>self, event: <a title="graia.broadcast.entities.event.BaseEvent" href="entities/event.html#graia.broadcast.entities.event.BaseEvent">BaseEvent</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postEvent(self, event: BaseEvent):
    self.loop.create_task(
        self.layered_scheduler(
            listener_generator=self.default_listener_generator(event.__class__),
            event=event,
        )
    )</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.receiver"><code class="name flex">
<span>def <span class="ident">receiver</span></span>(<span>self, event: Union[str, Type[<a title="graia.broadcast.entities.event.BaseEvent" href="entities/event.html#graia.broadcast.entities.event.BaseEvent">BaseEvent</a>]], priority: int = 16, dispatchers: List[Type[<a title="graia.broadcast.entities.dispatcher.BaseDispatcher" href="entities/dispatcher.html#graia.broadcast.entities.dispatcher.BaseDispatcher">BaseDispatcher</a>]] = [], namespace: <a title="graia.broadcast.entities.namespace.Namespace" href="entities/namespace.html#graia.broadcast.entities.namespace.Namespace">Namespace</a> = None, headless_decorators: List[<a title="graia.broadcast.entities.decorator.Decorator" href="entities/decorator.html#graia.broadcast.entities.decorator.Decorator">Decorator</a>] = [], enable_internal_access: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def receiver(
    self,
    event: Union[str, Type[BaseEvent]],
    priority: int = 16,
    dispatchers: List[Type[BaseDispatcher]] = [],
    namespace: Namespace = None,
    headless_decorators: List[Decorator] = [],
    enable_internal_access: bool = False,
):
    if cached_isinstance(event, str):
        _name = event
        event = self.findEvent(event)
        if not event:
            raise InvaildEventName(_name, &#34;is not vaild!&#34;)
    priority = (type(priority) == int) and priority or int(priority)  # 类型转换

    def receiver_wrapper(callable_target):
        may_listener = self.getListener(callable_target)
        if not may_listener:
            self.listeners.append(
                Listener(
                    callable=callable_target,
                    namespace=namespace or self.getDefaultNamespace(),
                    inline_dispatchers=dispatchers,
                    priority=priority,
                    listening_events=[event],
                    headless_decorators=headless_decorators,
                    enable_internal_access=enable_internal_access,
                )
            )
        else:
            if event not in may_listener.listening_events:
                may_listener.listening_events.append(event)
            else:
                raise RegisteredEventListener(
                    event.__name__, &#34;has been registered!&#34;
                )
        return callable_target

    return receiver_wrapper</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.removeListener"><code class="name flex">
<span>def <span class="ident">removeListener</span></span>(<span>self, target)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeListener(self, target):
    self.listeners.remove(target)</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.removeNamespace"><code class="name flex">
<span>def <span class="ident">removeNamespace</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeNamespace(self, name):
    if self.containNamespace(name):
        for index, i in enumerate(self.namespaces):
            if i.name == name:
                self.namespaces.pop(index)
                return
    else:
        raise UnexistedNamespace(name)</code></pre>
</details>
</dd>
<dt id="graia.broadcast.Broadcast.unhideNamespace"><code class="name flex">
<span>def <span class="ident">unhideNamespace</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unhideNamespace(self, name):
    ns = self.getNamespace(name)
    ns.hide = False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="graia" href="../index.html">graia</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="graia.broadcast.builtin" href="builtin/index.html">graia.broadcast.builtin</a></code></li>
<li><code><a title="graia.broadcast.entities" href="entities/index.html">graia.broadcast.entities</a></code></li>
<li><code><a title="graia.broadcast.exceptions" href="exceptions.html">graia.broadcast.exceptions</a></code></li>
<li><code><a title="graia.broadcast.interfaces" href="interfaces/index.html">graia.broadcast.interfaces</a></code></li>
<li><code><a title="graia.broadcast.interrupt" href="interrupt/index.html">graia.broadcast.interrupt</a></code></li>
<li><code><a title="graia.broadcast.priority" href="priority.html">graia.broadcast.priority</a></code></li>
<li><code><a title="graia.broadcast.typing" href="typing.html">graia.broadcast.typing</a></code></li>
<li><code><a title="graia.broadcast.utilles" href="utilles.html">graia.broadcast.utilles</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="graia.broadcast.Broadcast" href="#graia.broadcast.Broadcast">Broadcast</a></code></h4>
<ul class="">
<li><code><a title="graia.broadcast.Broadcast.Executor" href="#graia.broadcast.Broadcast.Executor">Executor</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.containListener" href="#graia.broadcast.Broadcast.containListener">containListener</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.containNamespace" href="#graia.broadcast.Broadcast.containNamespace">containNamespace</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.createNamespace" href="#graia.broadcast.Broadcast.createNamespace">createNamespace</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.debug_flag" href="#graia.broadcast.Broadcast.debug_flag">debug_flag</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.default_listener_generator" href="#graia.broadcast.Broadcast.default_listener_generator">default_listener_generator</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.default_namespace" href="#graia.broadcast.Broadcast.default_namespace">default_namespace</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.disableNamespace" href="#graia.broadcast.Broadcast.disableNamespace">disableNamespace</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.dispatcher_interface" href="#graia.broadcast.Broadcast.dispatcher_interface">dispatcher_interface</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.enableNamespace" href="#graia.broadcast.Broadcast.enableNamespace">enableNamespace</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.event_class_generator" href="#graia.broadcast.Broadcast.event_class_generator">event_class_generator</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.findEvent" href="#graia.broadcast.Broadcast.findEvent">findEvent</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.getDefaultNamespace" href="#graia.broadcast.Broadcast.getDefaultNamespace">getDefaultNamespace</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.getListener" href="#graia.broadcast.Broadcast.getListener">getListener</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.getNamespace" href="#graia.broadcast.Broadcast.getNamespace">getNamespace</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.hideNamespace" href="#graia.broadcast.Broadcast.hideNamespace">hideNamespace</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.layered_scheduler" href="#graia.broadcast.Broadcast.layered_scheduler">layered_scheduler</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.listeners" href="#graia.broadcast.Broadcast.listeners">listeners</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.loop" href="#graia.broadcast.Broadcast.loop">loop</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.namespaces" href="#graia.broadcast.Broadcast.namespaces">namespaces</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.postEvent" href="#graia.broadcast.Broadcast.postEvent">postEvent</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.receiver" href="#graia.broadcast.Broadcast.receiver">receiver</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.removeListener" href="#graia.broadcast.Broadcast.removeListener">removeListener</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.removeNamespace" href="#graia.broadcast.Broadcast.removeNamespace">removeNamespace</a></code></li>
<li><code><a title="graia.broadcast.Broadcast.unhideNamespace" href="#graia.broadcast.Broadcast.unhideNamespace">unhideNamespace</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>